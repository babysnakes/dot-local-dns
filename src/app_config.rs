use crate::prelude::*;
#[cfg_attr(test, allow(unused_imports))]
use serde::{Deserialize, Serialize};

#[derive(Deserialize, Serialize, Debug, PartialEq)]
pub struct AppConfig {
    pub top_level_domain: String,
    pub port: u16,
    pub log_level: String,
    pub logging_dir: PathBuf,
    pub records_file: PathBuf,
    pub start_at_login: bool,
    pub config_revision: ConfigRevision,
    #[serde(skip)]
    pub config_path: PathBuf,
}

/// These are variable that are changed between OS, runtime environment, etc...
#[derive(Clone)]
struct DynamicValues {
    records_file: PathBuf,
    config_dir: PathBuf,
    port: u16,
    log_level: String,
}

#[derive(Deserialize, Serialize, Debug, PartialEq)]
pub struct ConfigRevision {
    revision: u8,
}

impl AppConfig {
    pub fn new() -> Result<Self> {
        let values = DynamicValues::get()?;
        let config_path = values.config_dir.join("application.toml");
        if config_path.exists() {
            Self::from_file(config_path)
        } else {
            let config = Self::generate(config_path, values);
            config.init_files()?;
            Ok(config)
        }
    }

    pub fn set_start_at_login(&mut self, start: bool) -> Result<()> {
        if self.start_at_login == start {
            debug!("Start at login is already: {start}");
            Ok(())
        } else {
            debug!("Setting start at login to: {start}");
            self.start_at_login = start;
            self.save_with_comments()
        }
    }

    fn from_file(path: PathBuf) -> Result<Self> {
        fs::read_to_string(&path)
            .map_err(anyhow::Error::from)
            .and_then(|s| toml::from_str(&s).map_err(anyhow::Error::from))
            .map(|config| AppConfig {
                config_path: path,
                ..config
            })
    }

    fn generate(config_path: PathBuf, values: DynamicValues) -> Self {
        AppConfig {
            top_level_domain: DEFAULT_TOP_LEVEL_DOMAIN.to_string(),
            port: values.port,
            log_level: values.log_level,
            logging_dir: values.config_dir.join(LOGS_DIR_NAME),
            records_file: values.records_file,
            start_at_login: false,
            config_revision: ConfigRevision { revision: 0 },
            config_path,
        }
    }

    fn init_files(&self) -> Result<()> {
        fs::create_dir_all(&self.logging_dir)?;
        self.save_with_comments()
    }

    fn save_with_comments(&self) -> Result<()> {
        let config_str = toml::to_string_pretty(&self)?;
        let with_comments = format!(
            "{}{}\n\n{}\n{}\n{}",
            "# Application Configuration for ",
            APP_NAME,
            "# It is HIGHLY recommended that you DO NOT edit this file!",
            "# The only field that is somewhat safe to edit is the log_level which accepts one of (error, warn, info, debug, trace)",
            config_str,
        );
        let mut file = File::create(&self.config_path)?;
        file.write_all(with_comments.as_bytes())?;
        Ok(())
    }
}

impl DynamicValues {
    #[cfg(debug_assertions)]
    fn get() -> Result<Self> {
        let app_name = format!("{APP_NAME}-dev");
        let config_dir = app_config_dir()?.join(&app_name);
        let records_file = config_dir.join(DEFAULT_RECORDS_FILE_NAME);
        Ok(Self {
            config_dir,
            records_file,
            port: 2053,
            log_level: "debug".to_string(),
        })
    }

    #[cfg(not(debug_assertions))]
    fn get() -> Result<Self> {
        let config_dir = app_config_dir()?.join(APP_NAME);
        let records_file = config_dir.join(DEFAULT_RECORDS_FILE_NAME);
        Ok(Self {
            config_dir,
            records_file,
            port: 53,
            log_level: "info".to_string(),
        })
    }
}

pub fn app_config_dir() -> Result<PathBuf> {
    dirs::config_dir().with_context(|| "Could not find config directory")
}

#[cfg(test)]
mod tests {
    use super::*;
    use fake::faker::filesystem::en::*;
    use fake::Fake;
    use tempfile::tempdir;

    #[test]
    fn generate_produces_reasonable_defaults() {
        let dv = dynamic_values();
        let path = PathBuf::default();
        let config = AppConfig::generate(path.clone(), dv.clone());
        assert_eq!(config.port, dv.port);
        assert_eq!(config.log_level, "info".to_string());
        assert_eq!(config.records_file, dv.records_file);
        assert_eq!(
            config.top_level_domain,
            DEFAULT_TOP_LEVEL_DOMAIN.to_string()
        );
        assert_eq!(config.config_path, path);
    }

    #[test]
    fn save_and_load_config_test() {
        let dv = dynamic_values();
        let temp_dir = tempdir().unwrap();
        let config_file = temp_dir.path().join("config.toml");
        let config = AppConfig::generate(config_file.clone(), dv.clone());
        config.init_files().unwrap();
        let saved_str = fs::read_to_string(&config_file).unwrap();
        assert!(saved_str.contains("# Application Configuration for "));
        assert!(saved_str.contains(dv.records_file.to_str().unwrap()));
        assert!(
            !saved_str.contains("config_file"),
            "config_file should be skipped"
        );
        assert!(
            !saved_str.contains("startup_dir"),
            "startup_dir should be skipped"
        );
        let parsed = AppConfig::from_file(config_file).unwrap();
        assert_eq!(parsed, config);
    }

    fn dynamic_values() -> DynamicValues {
        DynamicValues {
            records_file: FilePath().fake(),
            config_dir: DirPath().fake(),
            port: 0,
            log_level: "info".to_string(),
        }
    }
}
