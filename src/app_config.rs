use crate::shared::APP_NAME;
#[cfg_attr(test, allow(unused_imports))]
use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

#[derive(Deserialize, Serialize, Debug, PartialEq)]
pub struct AppConfig {
    pub top_level_domain: String,
    pub port: u16,
    pub log_level: String,
    pub logging_dir: PathBuf,
    pub records_file: PathBuf,
    pub start_at_login: Option<bool>,
    pub config_revision: ConfigRevision,
}

struct DynamicValues {
    dyn_app_name: String,
    records_file: String,
    port: u16,
    log_level: String,
}

#[derive(Deserialize, Serialize, Debug, PartialEq)]
pub struct ConfigRevision {
    revision: u8,
}

impl AppConfig {
    pub fn new() -> Result<Self> {
        let values = DynamicValues::default();
        let config_dir = app_config_dir(&values.dyn_app_name)?;
        let config_path = config_dir.join("application.toml");
        if config_path.exists() {
            Self::from_file(config_path)
        } else {
            let config = Self::generate(&values)?;
            config.init_files(config_path)?;
            Ok(config)
        }
    }

    fn from_file(path: impl AsRef<Path>) -> Result<Self> {
        fs::read_to_string(&path)
            .map_err(anyhow::Error::from)
            .and_then(|s| toml::from_str(&s).map_err(anyhow::Error::from))
    }

    fn generate(values: &DynamicValues) -> Result<Self> {
        let config_dir = app_config_dir(&values.dyn_app_name)?;
        let records_file = get_home_dir().map(|p| p.join(&values.records_file))?;
        let logging_dir = config_dir.join("logs");
        Ok(AppConfig {
            top_level_domain: ".local".to_string(),
            port: values.port,
            log_level: values.log_level.clone(),
            logging_dir,
            records_file,
            start_at_login: None,
            config_revision: ConfigRevision { revision: 0 },
        })
    }

    fn init_files(&self, path: impl AsRef<Path>) -> Result<()> {
        fs::create_dir_all(&self.logging_dir)?;
        let config_str = toml::to_string_pretty(&self)?;
        let with_comments = format!(
            "{}{}\n\n{}\n{}\n{}", 
            "# Application Configuration for ",
            APP_NAME,
            "# It is HIGHLY recommended that you DO NOT edit this file!",
            "# The only field that is somewhat safe to edit is the log_level which accepts one of (error, warn, info, debug, trace)",
            config_str,
        );
        let mut file = fs::File::create(path)?;
        file.write_all(with_comments.as_bytes())?;
        Ok(())
    }
}

impl Default for DynamicValues {
    fn default() -> Self {
        if cfg!(debug_assertions) {
            Self {
                dyn_app_name: format!("{APP_NAME}-dev"),
                records_file: ".local-records-dev".to_string(),
                port: 2053,
                log_level: "debug".to_string(),
            }
        } else {
            Self {
                dyn_app_name: APP_NAME.to_string(),
                records_file: ".local-records".to_string(),
                port: 53,
                log_level: "info".to_string(),
            }
        }
    }
}

#[cfg(not(test))]
pub fn app_config_dir(app_name: &str) -> Result<PathBuf> {
    dirs::config_dir()
        .with_context(|| "Could not find config directory")
        .map(|p| p.join(app_name))
}

// Safeguard against test going amok.
#[allow(clippy::unnecessary_wraps)]
#[cfg(test)]
pub fn app_config_dir(_: &str) -> Result<PathBuf> {
    Ok(PathBuf::from("/tmp"))
}

#[cfg(not(test))]
pub fn get_home_dir() -> Result<PathBuf> {
    dirs::home_dir().with_context(|| "Failed to get home directory")
}

// Safeguard against test going amok.
#[allow(clippy::unnecessary_wraps)]
#[cfg(test)]
pub fn get_home_dir() -> Result<PathBuf> {
    Ok(PathBuf::from("/tmp"))
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn generate_produces_reasonable_defaults() {
        let dv = dynamic_values();
        let config = AppConfig::generate(&dv).unwrap();
        assert_eq!(config.port, dv.port);
        assert_eq!(config.log_level, "info".to_string());
        assert!(
            config
                .records_file
                .to_string_lossy()
                .contains(&dv.records_file),
            "records file should be named after provided file name"
        );
        assert_eq!(config.top_level_domain, ".local".to_string());
    }

    #[test]
    fn save_and_load_config_test() {
        let dv = dynamic_values();
        let config = AppConfig::generate(&dv).unwrap();
        let temp_dir = tempdir().unwrap();
        let config_file = temp_dir.path().join("config.toml");
        config.init_files(&config_file).unwrap();
        let saved_str = fs::read_to_string(&config_file).unwrap();
        assert!(saved_str.contains("# Application Configuration for "));
        assert!(saved_str.contains(&dv.records_file));
        let parsed = AppConfig::from_file(config_file).unwrap();
        assert_eq!(parsed, config);
    }

    fn dynamic_values() -> DynamicValues {
        DynamicValues {
            dyn_app_name: ".local-test".to_string(),
            records_file: ".local-records-test".to_string(),
            port: 0,
            log_level: "info".to_string(),
        }
    }
}
